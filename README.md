# Data Structure

# 逻辑结构和存储结构

### 逻辑结构
* 抽象的
* 描述数据元素之间的逻辑关系
* 对人类阅读更友好
* 分为：集合结构（无关系）， 线性结构（一对一）， 树形结构（一对多）， 图形结构（多对多）

### 存储结构
* 具体的
* 指的是数据结构在计算机中的具体表示
* 对机器更友好
* 分为：顺序存储， 链式存储， 索引存储， 散列存储

##### 顺序存储
* 能够随机存储（指的是能任意定位到随机的某个元素）
* 每个元素占用最少空间
* 必须使用整块的内存， 会产生较多内存碎片

##### 链式存储
* 只能顺序存储
* 每个元素需要额外空间存储下一节点指针
* 充分利用内存空间， 不会产生碎片

# 算法

### 概念
* 程序 = 数据结构 + 算法
* 是对特定问题求解步骤的一种描述
* 特性：
    1. 有穷性（有限的步骤， 不能无限循环）
    2. 确定性（每一步不能有歧义）
    3. 可行性（可以使用已有的基本操作来实现）
    4. 输入（0或多个输入）
    5. 输出（1或多个输出）

### 时间复杂度
* 事前预估算法的时间开销 `T（n）` 和问题规模 `n` 的关系， 或者说 `T（n）` 和 `O（f（n））` 的关系
* 只考虑n的高阶部分， 并且可以省略常数项系数， 使用 `O（n）` 来表示时间复杂度
* 只需要关注循环操作， 并且只需要关注最深层循环的次数
* `T（n）` 的加法， 只保留最高阶项， 乘法则都要保留
* $O（1） < O（log_2n） < O（n） < O（nlog_2n） < O（n^2）$
* 常对幂指阶记忆法
* 最坏时间复杂度， 平均时间复杂度（指所有示例出现概率相等情况下）， 最好时间复杂度

### 空间复杂度
* 内存开销S（n）和问题规模n的关系
* 考虑数组的占用， 递归调用栈空间的占用

# 线性表
* n个相同类型元素组成的有序的集合
* 元素个数有限， 元素数据类型相同， 逻辑上有顺序性
* 是逻辑结构中的线性结构

### 顺序表
* 是线性表的存储结构的实现方式1
* 可以随机存取， 每个节点只存储数据
* 插入删除操作效率低， 需要整段连续内存存储（底层数组实现）

### 单链表
* 是线性表的存储结构的实现方式2
* 插入删除只需要修改指针指向，所以速度快
* 无需连续存储空间
* 无法随机读取，查找需要从头开始
* 存储指针存在空间的浪费

##### 结构体数据占用空间问题
* 结构体指针本身占用空间4或者8，取决于32位或者64位系统
* 结构体内各个元素相加后凑整，8，16等

# 数组&矩阵

### 一维数组
* 地址，索引默认从0开始
$$ a[i] = 起始地址 + i * sizeof（ElemType） $$

### 二维数组
* 地址
* 行优先
  * $a[i][j] = 起始地址 + （i * N + j） * sizeof（ElemType）$   
* 列优先
  * $a[i][j] = 起始地址 + （j * M + i） * sizeof（ElemType）$

### 对称矩阵
* `n` 行 `n` 列，`a（i， j） = a（j， i）`
* 可以进行压缩存储，例如只存储主对角线数据以及下三角区数据
* 数组大小
  * $size = \frac{（1 + n） \times n}{2}$
* 由于从`0`开始，所以最后元素的索引为 $\frac{（1 + n） \times n}{2} - 1$
* 矩阵的元素下标 `a（i， j）` 对应到数组的索引下标，公式为：（以存储主对角线数据以及下三角区数据为例）
* 行优先
  * $a（i，j） = \frac{（1 + i - 1） \times （ i - 1 ）}{2} + j - 1 = \frac{i \times （ i - 1 ）}{2} + j - 1$
  * 解析：`i` 代表前面有 `i-1` 行，那么 `i-1` 行的元素个数即为$\frac{（1 + i - 1） \times （ i - 1 ）}{2}$，`j` 代表当前这一行是第 `j` 个元素，由于数组索引从 `0` 开始，所以对应的索引需要再减去 `1` （注意矩阵的 `i`，`j` 一般从 `1` 开始，而数组索引从 `0` 开始）
* 列优先 
  * $a（i，j） = \frac{（n + （n - （ j - 1 ） + 1）） \times （ j - 1 ）}{2} + （ i - j + 1 ） - 1$ 
  * 解析：`j` 代表前面有 `j-1` 列，每一列的个数从 `n` 开始递减，第 `j-1` 列的元素个数是 `n-(j-1)+1`，`(i-j+1)` 代表是当前列的第几个元素

### 三角矩阵
* 下三角矩阵 指的是上三角区所有元素都相同
* 数组大小 
  * $size = \frac{（1 + n） \times n}{2} + 1$ 
  * 多一个位置来存储上三角区相同元素

### 三对角矩阵
* 指的是 `|i-j|>1` 时，`a（i，j）= 0` 这样的矩阵，也就是除了主对角线元素以及和主对角线相差一个单位元素之外，剩余位置元素都是0
* 数组大小
  * $size = （ 3 \times n - 2 ）$
  * 解析：除了第一行和最后一行只有两个元素，其余行都是三个元素
* 索引（行优先） 
  * $a（i，j） = （ 3 \times （ i - 1 ） - 1 ） + （ j - i + 2 ） - 1 \\ = 2i+j-3$
  * 解析：前面一共有 `i-1` 行，第一行少一个元素，当前行使用 `j-i+2` 求出第几个元素位置，最后索引从 `0` 开始所以再减一
* 根据索引 `k` 反求 `i`，`j`
  * 解析：索引 `k`，代表是第 `k+1` 元素，根据不等式：前 `i-1` 行元素 < 第 `k+1` 元素 <= 前 `i` 行元素，假设一行 `3` 个元素，则有 $3（i-1）- 1 < k + 1 <= 3i - 1$，得 $i >= \frac{（k + 2）}{3}$，向上取整，再根据 $k = 2i + j - 3$，求出 `j`

### 稀疏矩阵
* 指的是非 `0` 元素个数远远少于 `0` 元素个数的矩阵
* 缺点：失去随机存取特性
* 使用一些技巧进行压缩存储，例如
  * 顺序存储三元组 （行号， 列号， 非 `0` 值） 行列号码从 `1` 开始
  * 链式存储十字链表法 

# 树&二叉树

### 树

##### 概念
* 度数：指的是结点有几个孩子
* 度为 `m` 的树：指的是这棵树至少有一个结点的度为 `m`，一定是非空树，至少有 `m+1` 结点
* m叉树：指的是允许所有结点的度小于 `m` ，可以是空树

##### 性质
1. 结点数量 = 总分支数(总度数) + 1 
2. 总分支数(总度数) = $1n_1 + 2n_2 + 3n_3 + ... + mn_m$
3. 结点数量 = $n_0 + n_1 + n_2 + n_3 + ... + n_m$
4. `n` 个结点的树有 `n-1` 条边
5. 度为 `m` 的树，第 `i` 层，至多有 $m^i - 1$ 个结点
6. 高度 `h` 度为 `m` 的树，至少有 $h + m - 1$ 个结点
7. `m` 叉树，第 `i` 层，至多有 $m^i - 1$ 个结点
8. 高度 `h` 的 `m` 叉树，至多有 $（m^0 + m^1 + m^2 + ... + m^h - 1）\\ = \frac{（1 - m^h）}{1 - m}$ 个结点
9. 高度 `h` 的 `m` 叉树，至少有 `h` 个结点
10. `n` 个结点的 `m` 叉树，最小高度是 $log_m （n（m - 1） + 1）$ 向上取整

### 二叉树

##### 满二叉树 
* 高度 `h` ，有 $2^h - 1$ 个结点 
* 性质
  * 只有最后一层才会出现叶子结点 
  * 不存在度为 `1` 的结点 
  * 从上到下从左到右编号，从 `1` 开始 结点 `i` 的左孩子是 `2i` ，右孩子是 `2i+1` ，父结点是 $\frac{i}{2}$ 向下取整

##### 完全二叉树
* 就是最后一层不满的满二叉树
* 完全二叉树不一定是满二叉树，而满二叉树一定是完全二叉树
* 直观理解就是连续的去除掉最后一层中编号较大的叶子结点
* 性质
  * 只有最后一层以及倒数第二层会出现叶子结点
  * 最多只有一个度为 `1` 的结点
  * 从上到下从左到右编号，从 `1` 开始 结点 `i` 的左孩子是 `2i` ，右孩子是 `2i+1` ，父结点是 $\frac{i}{2}$ 向下取整
  * `n` 个结点的完全二叉树，$i <= \frac{n}{2}$ 取整时代表 `i` 是分支结点，$i > \frac{n}{2}$ 取整时代表 `i` 是叶子结点

##### 二叉排序树
* 左子树所有结点的关键字（即数值）都小于根结点的关键字
* 右子树所有结点的关键字都大于根结点的关键字

##### 平衡二叉树
* 任意结点的左子树和右子树的高度（深度）之差小于等于 `1`

### 常见考点
1. 非空二叉树，度为 `0` ，`1` ，`2` 的结点个数为 $n_0$，$n_1$，$n_2$，则有 $n_0 = n_2 + 1$，而 $n_1$ 只可能取值 `0` 或者 `1`
2. 二叉树，第 `i` 层的结点数量，最多是 $2^i - 1$
3. 高度 `h` ，二叉树，最多有 $2^h - 1$ 结点（即满二叉树）
4. 完全二叉树，n个结点，高度为 $h = log_2(n + 1)$ 向上取整
5. n个结点的二叉链表有n+1个空指针域,可以构建线索二叉树
6. m叉树,结点i,双亲编号$\frac{(i-2)}{m}向下取整+1$,而第一个子女编号为$(i-1) \times m + 2$,第k个子女编号为$(i-1) \times m + k + 1$

### 二叉树的存储结构

##### 顺序存储
* i结点的左孩子,右孩子,父结点
* 适合存储完全二叉树,存储普通二叉树时可能会浪费很多内存空间
 
##### 链式存储
* n个结点的二叉链表有n+1个空指针域,可以构建线索二叉树

### 二叉树的遍历

##### 根据序列构建二叉树
* 仅仅凭借前序序列或者中序序列或者后序序列或者层序序列,是无法构建唯一二叉树的
* 前序+中序：前序序列的首元素就是根节点,但是要结合中序序列
* 后序+中序：后序序列的最后元素就是根节点,但是要结合中序序列
* 层序+中序：层序遍历的首元素就是根节点,第二个元素就是左子树根节点,第三个元素就是右子树的根节点,但是要结合中序序列
* 必须结合中序序列才能确定唯一二叉树

### 线索二叉树
* 使用空的链表域记录前驱,后继结点,目的是为了方便的找到结点前驱和后继
* 额外增加ltag和rtag来区分孩子结点还是线索结点
* 中序序列,前序序列,后序序列都可以更改后变成线索二叉树

