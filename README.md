# Data Structure

# 逻辑结构和存储结构

### 逻辑结构
* 抽象的
* 描述数据元素之间的逻辑关系
* 对人类阅读更友好
* 分为：集合结构（无关系）， 线性结构（一对一）， 树形结构（一对多）， 图形结构（多对多）

### 存储结构
* 具体的
* 指的是数据结构在计算机中的具体表示
* 对机器更友好
* 分为：顺序存储， 链式存储， 索引存储， 散列存储

##### 顺序存储
* 能够随机存储（指的是能任意定位到随机的某个元素）
* 每个元素占用最少空间
* 必须使用整块的内存， 会产生较多内存碎片

##### 链式存储
* 只能顺序存储
* 每个元素需要额外空间存储下一节点指针
* 充分利用内存空间， 不会产生碎片

# 算法

### 概念
* 程序 = 数据结构 + 算法
* 是对特定问题求解步骤的一种描述
* 特性：
    1. 有穷性（有限的步骤， 不能无限循环）
    2. 确定性（每一步不能有歧义）
    3. 可行性（可以使用已有的基本操作来实现）
    4. 输入（0或多个输入）
    5. 输出（1或多个输出）

### 时间复杂度
* 事前预估算法的时间开销 `T（n）` 和问题规模 `n` 的关系， 或者说 `T（n）` 和 `O（f（n））` 的关系
* 只考虑n的高阶部分， 并且可以省略常数项系数， 使用 `O（n）` 来表示时间复杂度
* 只需要关注循环操作， 并且只需要关注最深层循环的次数
* `T（n）` 的加法， 只保留最高阶项， 乘法则都要保留
* $O（1） < O（log_2n） < O（n） < O（nlog_2n） < O（n^2）$
* 常对幂指阶记忆法
* 最坏时间复杂度， 平均时间复杂度（指所有示例出现概率相等情况下）， 最好时间复杂度

### 空间复杂度
* 内存开销S（n）和问题规模n的关系
* 考虑数组的占用， 递归调用栈空间的占用

# 线性表
* n个相同类型元素组成的有序的集合
* 元素个数有限， 元素数据类型相同， 逻辑上有顺序性
* 是逻辑结构中的线性结构

### 顺序表
* 是线性表的存储结构的实现方式1
* 可以随机存取， 每个节点只存储数据
* 插入删除操作效率低， 需要整段连续内存存储（底层数组实现）

### 单链表
* 是线性表的存储结构的实现方式2
* 插入删除只需要修改指针指向，所以速度快
* 无需连续存储空间
* 无法随机读取，查找需要从头开始
* 存储指针存在空间的浪费

##### 结构体数据占用空间问题
* 结构体指针本身占用空间4或者8，取决于32位或者64位系统
* 结构体内各个元素相加后凑整，8，16等

# 数组&矩阵

### 一维数组
* 地址，索引默认从0开始
$$ a[i] = 起始地址 + i * sizeof（ElemType） $$

### 二维数组
* 地址
* 行优先
  * $a[i][j] = 起始地址 + （i * N + j） * sizeof（ElemType）$   
* 列优先
  * $a[i][j] = 起始地址 + （j * M + i） * sizeof（ElemType）$

### 对称矩阵
* `n` 行 `n` 列，`a（i， j） = a（j， i）`
* 可以进行压缩存储，例如只存储主对角线数据以及下三角区数据
* 数组大小
  * $size = \frac{（1 + n） \times n}{2}$
* 由于从`0`开始，所以最后元素的索引为 $\frac{（1 + n） \times n}{2} - 1$
* 矩阵的元素下标 `a（i， j）` 对应到数组的索引下标，公式为：（以存储主对角线数据以及下三角区数据为例）
* 行优先
  * $a（i，j） = \frac{（1 + i - 1） \times （ i - 1 ）}{2} + j - 1 = \frac{i \times （ i - 1 ）}{2} + j - 1$
  * 解析：`i` 代表前面有 `i-1` 行，那么 `i-1` 行的元素个数即为$\frac{（1 + i - 1） \times （ i - 1 ）}{2}$，`j` 代表当前这一行是第 `j` 个元素，由于数组索引从 `0` 开始，所以对应的索引需要再减去 `1` （注意矩阵的 `i`，`j` 一般从 `1` 开始，而数组索引从 `0` 开始）
* 列优先 
  * $a（i，j） = \frac{（n + （n - （ j - 1 ） + 1）） \times （ j - 1 ）}{2} + （ i - j + 1 ） - 1$ 
  * 解析：`j` 代表前面有 `j-1` 列，每一列的个数从 `n` 开始递减，第 `j-1` 列的元素个数是 `n-(j-1)+1`，`(i-j+1)` 代表是当前列的第几个元素

### 三角矩阵
* 下三角矩阵 指的是上三角区所有元素都相同
* 数组大小 
  * $size = \frac{（1 + n） \times n}{2} + 1$ 
  * 多一个位置来存储上三角区相同元素

### 三对角矩阵
* 指的是 `|i-j|>1` 时，`a（i，j）= 0` 这样的矩阵，也就是除了主对角线元素以及和主对角线相差一个单位元素之外，剩余位置元素都是0
* 数组大小
  * $size = （ 3 \times n - 2 ）$
  * 解析：除了第一行和最后一行只有两个元素，其余行都是三个元素
* 索引（行优先） 
  * $a（i，j） = （ 3 \times （ i - 1 ） - 1 ） + （ j - i + 2 ） - 1 \\ = 2i+j-3$
  * 解析：前面一共有 `i-1` 行，第一行少一个元素，当前行使用 `j-i+2` 求出第几个元素位置，最后索引从 `0` 开始所以再减一
* 根据索引 `k` 反求 `i`，`j`
  * 解析：索引 `k`，代表是第 `k+1` 元素，根据不等式：前 `i-1` 行元素 < 第 `k+1` 元素 <= 前 `i` 行元素，假设一行 `3` 个元素，则有 $3（i-1）- 1 < k + 1 <= 3i - 1$，得 $i >= \frac{（k + 2）}{3}$，向上取整，再根据 $k = 2i + j - 3$，求出 `j`

### 稀疏矩阵
* 指的是非 `0` 元素个数远远少于 `0` 元素个数的矩阵
* 缺点：失去随机存取特性
* 使用一些技巧进行压缩存储，例如
  * 顺序存储三元组 （行号， 列号， 非 `0` 值） 行列号码从 `1` 开始
  * 链式存储十字链表法 

# 树&二叉树

### 树

##### 概念
* 度数：指的是结点有几个孩子
* 度为 `m` 的树：指的是这棵树至少有一个结点的度为 `m`，一定是非空树，至少有 `m+1` 结点
* m叉树：指的是允许所有结点的度小于 `m` ，可以是空树

##### 性质
1. 结点数量 = 总分支数(总度数) + 1 
2. 总分支数(总度数) = $1n_1 + 2n_2 + 3n_3 + ... + mn_m$
3. 结点数量 = $n_0 + n_1 + n_2 + n_3 + ... + n_m$
4. `n` 个结点的树有 `n-1` 条边
5. 度为 `m` 的树，第 `i` 层，至多有 $m^i - 1$ 个结点
6. 高度 `h` 度为 `m` 的树，至少有 $h + m - 1$ 个结点
7. `m` 叉树，第 `i` 层，至多有 $m^i - 1$ 个结点
8. 高度 `h` 的 `m` 叉树，至多有 $（m^0 + m^1 + m^2 + ... + m^h - 1）\\ = \frac{（1 - m^h）}{1 - m}$ 个结点
9. 高度 `h` 的 `m` 叉树，至少有 `h` 个结点
10. `n` 个结点的 `m` 叉树，最小高度是 $log_m （n（m - 1） + 1）$ 向上取整

### 二叉树

##### 满二叉树 
* 高度 `h` ，有 $2^h - 1$ 个结点 
* 性质
  * 只有最后一层才会出现叶子结点 
  * 不存在度为 `1` 的结点 
  * 从上到下从左到右编号，从 `1` 开始 结点 `i` 的左孩子是 `2i` ，右孩子是 `2i+1` ，父结点是 $\frac{i}{2}$ 向下取整

##### 完全二叉树
* 就是最后一层不满的满二叉树
* 完全二叉树不一定是满二叉树，而满二叉树一定是完全二叉树
* 直观理解就是连续的去除掉最后一层中编号较大的叶子结点
* 性质
  * 只有最后一层以及倒数第二层会出现叶子结点
  * 最多只有一个度为 `1` 的结点
  * 从上到下从左到右编号，从 `1` 开始 结点 `i` 的左孩子是 `2i` ，右孩子是 `2i+1` ，父结点是 $\frac{i}{2}$ 向下取整
  * `n` 个结点的完全二叉树，$i <= \frac{n}{2}$ 取整时代表 `i` 是分支结点，$i > \frac{n}{2}$ 取整时代表 `i` 是叶子结点

##### 二叉排序树
* 左子树所有结点的关键字（即数值）都小于根结点的关键字
* 右子树所有结点的关键字都大于根结点的关键字

##### 平衡二叉树
* 任意结点的左子树和右子树的高度（深度）之差小于等于 `1`

### 常见考点
1. 非空二叉树，度为 `0` ，`1` ，`2` 的结点个数为 $n_0$，$n_1$，$n_2$，则有 $n_0 = n_2 + 1$，而 $n_1$ 只可能取值 `0` 或者 `1`
2. 二叉树，第 `i` 层的结点数量，最多是 $2^i - 1$
3. 高度 `h` ，二叉树，最多有 $2^h - 1$ 结点（即满二叉树）
4. 完全二叉树，n个结点，高度为 $h = log_2(n + 1)$ 向上取整
5. n个结点的二叉链表有n+1个空指针域,可以构建线索二叉树
6. m叉树,结点i,双亲编号$\frac{(i-2)}{m}向下取整+1$,而第一个子女编号为$(i-1) \times m + 2$,第k个子女编号为$(i-1) \times m + k + 1$

### 二叉树的存储结构

##### 顺序存储
* i结点的左孩子,右孩子,父结点
* 适合存储完全二叉树,存储普通二叉树时可能会浪费很多内存空间
 
##### 链式存储
* n个结点的二叉链表有n+1个空指针域,可以构建线索二叉树

### 二叉树的遍历

##### 根据序列构建二叉树
* 仅仅凭借前序序列或者中序序列或者后序序列或者层序序列,是无法构建唯一二叉树的
* 前序+中序：前序序列的首元素就是根节点,但是要结合中序序列
* 后序+中序：后序序列的最后元素就是根节点,但是要结合中序序列
* 层序+中序：层序遍历的首元素就是根节点,第二个元素就是左子树根节点,第三个元素就是右子树的根节点,但是要结合中序序列
* 必须结合中序序列才能确定唯一二叉树

### 线索二叉树
* 使用空的链表域记录前驱,后继结点,目的是为了方便的找到结点前驱和后继
* 额外增加ltag和rtag来区分孩子结点还是线索结点
* 中序序列,前序序列,后序序列都可以更改后变成线索二叉树

# 树&二叉树

### 树的存储结构

##### 树的逻辑结构
* 分支结点可以有多个子树

##### 双亲表示法
* 使用数组存储结点,类似于静态链表
* 结点=数据值+父结点地址
* 可以存储树,森林
* 找父结点容易,但是找子结点困难,需要完整遍历数组,适用于并查集的场景

##### 孩子表示法
* 顺序存储+链式存储实现
* 结点=数据值+孩子结点地址,多个孩子结点使用链表
* 可以存储树,森林
* 找子结点容易,但是找父结点困难,适用于服务流程树的场景(如客服电话)

##### 孩子兄弟表示法
* 类似二叉树,使用二叉链表实现
* 可以存储树,森林

### 树&森林&二叉树的相互转换

##### 树转换成二叉树
* 使用孩子兄弟表示法,就可以把树转换成二叉树
* 具体流程
  * 根节点,并且右孩子一定是null
  * 按照层序遍历进行结点的处理
  * 如果结点有孩子结点,则使用右指针串起来,并且指向结点的左指针

##### 森林转换成二叉树
* 同上面树转换成二叉树
* 区别是处理根节点时,需要把所有根节点使用右指针串起来

##### 二叉树转换成树
* 具体流程
  * 根节点
  * 按照层序遍历顺序处理其他结点
  * 如果结点有左孩子,将左孩子以及一串右指针拆下来,按照从左到右的顺序作为结点的子结点
  * 如果没有左孩子,就不处理

##### 二叉树转换成森林
* 根节点的处理不同,其余和上面二叉树转换成树的流程一样
* 根节点的处理需要把右指针串作为森林的跟

### 树

##### 先根遍历
* 类似于二叉树的前序遍历
* 同样可以使用手动划线的方法确定顺序
* 使用孩子兄弟法转换成二叉树后可以发现 二叉树的前序遍历和树的先根遍历一样
* 称之为深度优先遍历

##### 后根遍历
* 类似于二叉树的中序遍历
* 由于不知道有几个子结点,所以没办法使用手动划线的方法确定顺序,只能使用常规方法确定
* 使用孩子兄弟法转换成二叉树后可以发现 二叉树的中序遍历和树的后根遍历一样
* 称之为深度优先遍历

##### 层序遍历
* 类似于二叉树的层序遍历
* 称之为广度优先遍历

### 森林遍历

##### 先序遍历
* 方式1:针对每一颗树进行先序遍历
* 方式2:转换成二叉树后,进行前序遍历

##### 中序遍历(后根)
* 方式1:针对每一颗树进行后序遍历
* 方式2:转换成二叉树后,进行中序遍历

### 考点
* 如果森林中非叶子结点数量为n,则对应二叉树中右指针为空数量为n+1,因为每一个非叶子节点代表其孩子中最后那个的右指针肯定为空,同时根节点最右兄弟的右指针也为空,所以是n+1
* 如果树的对应二叉树左指针域为空的数量是n,代表该结点没有子结点,是叶结点,即叶结点数量也是n

### 树&二叉树的应用

##### 哈夫曼树&哈夫曼编码

概念
* 结点的权: 类似权重
* 结点的权路径长度: 根到该结点的路径长度乘以该结点权
* 树的权路径长度(WPL): 所有叶结点的权路径长度之和
* 哈夫曼树: WPL最小的二叉树,也叫做最优二叉树
* 哈夫曼编码: 用构建哈夫曼树的方式去构建的字符集编码,字符集的每个字符作为叶子结点,字符的出现频率作为权重,
二叉树的左路径和右路径分别代表0/1(或者1/0)
* 可变长度编码: 不同的字符使用不同长度的二进制数表示
* 前缀编码: 没有编码是其他编码的前缀,即能够区分开不同编码

构建哈夫曼树
* 给定n个结点来构建一颗哈夫曼树
* n个结点作为n棵树所形成的的森林
* 选择权重最小的两个结点,构建一颗新的树,其权重是两个子结点权重之和
* 新树加入森林,并且删除掉刚刚构建使用的两个子结点
* 重复上面两个步骤,一直到森林中只剩下一棵树

考点
* n个叶结点构建的哈夫曼树,其总结点数量为2n-1
* 哈夫曼树没有度为1的结点,因为都是两两组合重复构建出来的
* n个叶结点构建的哈夫曼树,并不是唯一结构的,但是WPL都是最优的
* 哈夫曼树的权路径长度计算方法
  * 所有叶结点的权路径长度之和
  * 所有分支结点的权之和
* 度为m的哈夫曼树,只会包含度为0和度为m的结点,则结点总数N为
  * $N=n_0+n_m$
  * $N=mn_m+1$
* 度为m的哈夫曼树,只会包含度为0和度为m的结点,叶结点个数为n,则非叶结点个数为 $\frac{n-1}{m-1}$,特别的,当m=2时,退化成n-1
* 定长编码集:在定长编码集中,所有字符都处于相同一层,而且都是叶结点
* 哈夫曼编码的加权平均长度算法:$\frac{WPL}{叶结点权值之和}$

##### 并查集

概念
* 集合这种逻辑结构可以使用树(森林)进行表示
* 树的双亲表示法的应用场景
* 查询操作: 向上查找根节点,最坏时间复杂度 $O(n)$
* 合并操作: 向上查找到根节点,然后合并两棵树,时间复杂度 $O(1)$
* n个独立结点多次union合并为一棵树(集合),最坏时间复杂度 $O(n^2)$

优化合并操作
* 根节点的parent不再单纯存储-1,而是存储-n,n代表这棵树的结点总数
* 两棵树合并时,让小树合并到大树
* 构建的树的高度不超过 $log_2 n (向下取整) + 1$
* 优化后查询的最坏时间复杂度 $O(log_2 n)$
* n个独立结点多次union合并为一棵树(集合),最坏时间复杂度 $O(nlog_2 n)$

优化查询操作
* 压缩路径
* 第一次循环,找到根结点
* 第二次循环,也是向上寻找根节点,但是在寻找的过程中,把经历过的结点,都直接挂载到根节点下
* 新构建的树高度不超过 $O(α(n))$,常见的n值的α(n)的值小于等于4,能大幅度优化查询和合并操作,查询的最坏时间复杂度即 $O(α(n))$
* n个独立结点多次union合并为一棵树(集合),最坏时间复杂度 $O(nα(n))$

# 图

### 概念

##### 基本概念
* 图由顶点集和边集组成
* 图不能为空,即图的顶点集不能为空,但是边集可以为空
* 集合本质上就是一种图(边集为空,但是顶点集不空)

##### 无向图&有向图概念
* 无向图:即边没有方向的概念,(使用圆括号表示一条边)
* 有向图:边是有方向的,(使用尖括号表示一条边)

##### 度&出度&入度概念

无向图
* 顶点的度:指的是对应到边的条数

有向图
* 顶点的入度:以顶点为终点的边条数
* 顶点的出度:以顶点为起点的边条数

##### 点到点关系概念

路径&回路&简单路径&简单回路
* 路径:一个顶点到另一个顶点之间经过的顶点的序列
* 回路:第一个顶点和最后一个顶点相同的路径
* 简单路径:顶点不重复的路径
* 简单回路:顶点不重复(除了第一个顶点和最后一个顶点外)的回路

路径长度
* 路径上的边的总数量

点到点的距离
* 指的是两个顶点之间最短路径,若不存在路径,则记作无穷 $\infty$

连通性&连通图
* 指的是无向图
* 连通性:无向图中,顶点到顶点有路径存在,则为连通
* 连通图:无向图中,任意两个顶点都是连通的

强连通性&强连通图
* 指的是有向图
* 强连通性:有向图中,顶点到顶点既有正向路径也有逆向路径,则为强连通
* 强连通图:有向图中,任意两个顶点都是强连通的

##### 边的权&带权图/网概念
* 网:指的是图的每条边都有权重值,也叫做带权图

##### 图的局部概念
* 极大连通子图:指的是子图是连通的,并且包含尽可能多的顶点和边
* 极大强连通子图:指的是子图是强连通的,并且包含尽可能多的顶点和边
* 连通分量:指的是无向图的极大连通子图,称之为连通分量,(注意需要极大)
* 强连通分量:指的是有向图的极大强连通子图,称之为强连通分量,(注意需要极大) 
* 极小连通子图:指的是边要尽可能的少,即n个顶点最少n-1条边
* 连通无向图的生成树:指的是连通无向图中,包含全部顶点的极小连通子图,可能有多种形态
* 非连通无向图的生成森林:指的是非连通无向图中,先找出所有的连通分量,再把所有连通分量改造为对应的生成树,这些生成树整体就构建了生成森林

### 特殊的图
* 无向完全图:指的是任意两个顶点之间都有边
* 有向完全图:指的是任意两个顶点之间都有相反两条边
* 稀疏图,一般来说边界是 $|E| < |VlogV|$
* 稠密图
* 树:本质上就是一个不存在回路的,连通的,无向的图,n个顶点最少n-1条边
* 森林:本质上就是一个个的连通的,无向的,极小连通子图
* 有向树:指的是一个顶点的入度为0,其余顶点的入度为1,的有向图

### 常见考点

n个顶点的无向图
* 所有顶点度之和为 $2\times边条数$
* 如果是连通图,则最少有 $n-1$ 条边,(例如一个根结点剩下都是子结点的树)
* 逆推:如果最少边的情况下减去一条边,就由连通变成不连通了 ![alt text](10E47670.png)
* 如果是连通图,若边长数量大于 $n-1$ ,则一定有回路
* 如果是非连通图,则最多有 $C_{n-1}^{2}$条边,(例如抛开一个顶点,让剩余n-1个顶点互相之间都连通,即是最大条数)
* 逆推:如果最多边的情况下加上一条边,就由不连通变成连通 ![alt text](10E47670.png)
* 如果是无向完全图,边的数量是 $C_{n}^{2}$

n个顶点的有向图
* 所有顶点的出度之和=入度之和=边条数
* 所有顶点的度之和等于 $2\times边条数$
* 如果是强连通图,则最少n条边,(例如刚好形成一个回路)
* 如果是有向完全图,边的数量是 $2C_{n}^{2}$
